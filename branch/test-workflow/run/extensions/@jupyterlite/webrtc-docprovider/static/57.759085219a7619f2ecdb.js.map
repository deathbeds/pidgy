{"version":3,"file":"57.759085219a7619f2ecdb.js?v=759085219a7619f2ecdb","mappings":"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","sources":["webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/binary.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/buffer.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/decoding.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/number.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/encoding.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/environment.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/conditions.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/object.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/function.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/map.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/math.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/set.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/array.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/observable.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/storage.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/string.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/lib0/time.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/process/browser.js","webpack://@jupyterlite/webrtc-docprovider/./node_modules/y-protocols/awareness.js"],"sourcesContent":["/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data => {\n  const encoder = encoding.createEncoder()\n  encoding.writeAny(encoder, data)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing the position\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 53) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let len = 6\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 53) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nexport const readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nexport const HIGHEST_INT32 = binary.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\nexport const parseInt = Number.parseInt\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num >>>= 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && math.abs(data) <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  /* istanbul ignore else */\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\n\n/* istanbul ignore next */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nexport const isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nexport const isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasParam = name => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nexport const getParam = (name, defaultVal) => computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nexport const getVariable = name => isNode ? conditions.undefinedToNull(process.env[name.toUpperCase()]) : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nexport const getConf = name => computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasConf = name => hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nexport const production = hasConf('production')\n","/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {T}\n */\nexport const first = set => {\n  return set.values().next().value || undefined\n}\n\n/**\n * @template T\n * @param {Iterable<T>} entries\n * @return {Set<T>}\n */\nexport const from = entries => {\n  return new Set(entries)\n}\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n\nexport const isArray = Array.isArray\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n","/* global localStorage, addEventListener */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} newValue\n   */\n  setItem (key, newValue) {\n    this.map.set(key, newValue)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\nlet usePolyfill = true\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n    usePolyfill = false\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nexport const varStorage = _localStorage\n\n/* istanbul ignore next */\n/**\n * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.\n *\n * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler\n * @function\n */\nexport const onChange = eventHandler => usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))\n","/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n\n/**\n * @param {string} str The initial string\n * @param {number} index Starting position\n * @param {number} remove Number of characters to remove\n * @param {string} insert New content to insert\n */\nexport const splice = (str, index, remove, insert = '') => str.slice(0, index) + insert + str.slice(index + remove)\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/**\n * @module awareness-protocol\n */\n\nimport * as encoding from 'lib0/encoding'\nimport * as decoding from 'lib0/decoding'\nimport * as time from 'lib0/time'\nimport * as math from 'lib0/math'\nimport { Observable } from 'lib0/observable'\nimport * as f from 'lib0/function'\nimport * as Y from 'yjs' // eslint-disable-line\n\nexport const outdatedTimeout = 30000\n\n/**\n * @typedef {Object} MetaClientState\n * @property {number} MetaClientState.clock\n * @property {number} MetaClientState.lastUpdated unix timestamp\n */\n\n/**\n * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information\n * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of\n * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.\n *\n * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override\n * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is\n * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that\n * a remote client is offline, it may propagate a message with\n * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a\n * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.\n *\n * Before a client disconnects, it should propagate a `null` state with an updated clock.\n *\n * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.\n *\n * @extends {Observable<string>}\n */\nexport class Awareness extends Observable {\n  /**\n   * @param {Y.Doc} doc\n   */\n  constructor (doc) {\n    super()\n    this.doc = doc\n    /**\n     * @type {number}\n     */\n    this.clientID = doc.clientID\n    /**\n     * Maps from client id to client state\n     * @type {Map<number, Object<string, any>>}\n     */\n    this.states = new Map()\n    /**\n     * @type {Map<number, MetaClientState>}\n     */\n    this.meta = new Map()\n    this._checkInterval = /** @type {any} */ (setInterval(() => {\n      const now = time.getUnixTime()\n      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {\n        // renew local clock\n        this.setLocalState(this.getLocalState())\n      }\n      /**\n       * @type {Array<number>}\n       */\n      const remove = []\n      this.meta.forEach((meta, clientid) => {\n        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n          remove.push(clientid)\n        }\n      })\n      if (remove.length > 0) {\n        removeAwarenessStates(this, remove, 'timeout')\n      }\n    }, math.floor(outdatedTimeout / 10)))\n    doc.on('destroy', () => {\n      this.destroy()\n    })\n    this.setLocalState({})\n  }\n\n  destroy () {\n    this.emit('destroy', [this])\n    this.setLocalState(null)\n    super.destroy()\n    clearInterval(this._checkInterval)\n  }\n\n  /**\n   * @return {Object<string,any>|null}\n   */\n  getLocalState () {\n    return this.states.get(this.clientID) || null\n  }\n\n  /**\n   * @param {Object<string,any>|null} state\n   */\n  setLocalState (state) {\n    const clientID = this.clientID\n    const currLocalMeta = this.meta.get(clientID)\n    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1\n    const prevState = this.states.get(clientID)\n    if (state === null) {\n      this.states.delete(clientID)\n    } else {\n      this.states.set(clientID, state)\n    }\n    this.meta.set(clientID, {\n      clock,\n      lastUpdated: time.getUnixTime()\n    })\n    const added = []\n    const updated = []\n    const filteredUpdated = []\n    const removed = []\n    if (state === null) {\n      removed.push(clientID)\n    } else if (prevState == null) {\n      if (state != null) {\n        added.push(clientID)\n      }\n    } else {\n      updated.push(clientID)\n      if (!f.equalityDeep(prevState, state)) {\n        filteredUpdated.push(clientID)\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])\n    }\n    this.emit('update', [{ added, updated, removed }, 'local'])\n  }\n\n  /**\n   * @param {string} field\n   * @param {any} value\n   */\n  setLocalStateField (field, value) {\n    const state = this.getLocalState()\n    if (state !== null) {\n      this.setLocalState({\n        ...state,\n        [field]: value\n      })\n    }\n  }\n\n  /**\n   * @return {Map<number,Object<string,any>>}\n   */\n  getStates () {\n    return this.states\n  }\n}\n\n/**\n * Mark (remote) clients as inactive and remove them from the list of active peers.\n * This change will be propagated to remote clients.\n *\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @param {any} origin\n */\nexport const removeAwarenessStates = (awareness, clients, origin) => {\n  const removed = []\n  for (let i = 0; i < clients.length; i++) {\n    const clientID = clients[i]\n    if (awareness.states.has(clientID)) {\n      awareness.states.delete(clientID)\n      if (clientID === awareness.clientID) {\n        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))\n        awareness.meta.set(clientID, {\n          clock: curMeta.clock + 1,\n          lastUpdated: time.getUnixTime()\n        })\n      }\n      removed.push(clientID)\n    }\n  }\n  if (removed.length > 0) {\n    awareness.emit('change', [{ added: [], updated: [], removed }, origin])\n    awareness.emit('update', [{ added: [], updated: [], removed }, origin])\n  }\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Array<number>} clients\n * @return {Uint8Array}\n */\nexport const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n  const len = clients.length\n  const encoder = encoding.createEncoder()\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = clients[i]\n    const state = states.get(clientID) || null\n    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(state))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Modify the content of an awareness update before re-encoding it to an awareness update.\n *\n * This might be useful when you have a central server that wants to ensure that clients\n * cant hijack somebody elses identity.\n *\n * @param {Uint8Array} update\n * @param {function(any):any} modify\n * @return {Uint8Array}\n */\nexport const modifyAwarenessUpdate = (update, modify) => {\n  const decoder = decoding.createDecoder(update)\n  const encoder = encoding.createEncoder()\n  const len = decoding.readVarUint(decoder)\n  encoding.writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    const clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const modifiedState = modify(state)\n    encoding.writeVarUint(encoder, clientID)\n    encoding.writeVarUint(encoder, clock)\n    encoding.writeVarString(encoder, JSON.stringify(modifiedState))\n  }\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * @param {Awareness} awareness\n * @param {Uint8Array} update\n * @param {any} origin This will be added to the emitted change event\n */\nexport const applyAwarenessUpdate = (awareness, update, origin) => {\n  const decoder = decoding.createDecoder(update)\n  const timestamp = time.getUnixTime()\n  const added = []\n  const updated = []\n  const filteredUpdated = []\n  const removed = []\n  const len = decoding.readVarUint(decoder)\n  for (let i = 0; i < len; i++) {\n    const clientID = decoding.readVarUint(decoder)\n    let clock = decoding.readVarUint(decoder)\n    const state = JSON.parse(decoding.readVarString(decoder))\n    const clientMeta = awareness.meta.get(clientID)\n    const prevState = awareness.states.get(clientID)\n    const currClock = clientMeta === undefined ? 0 : clientMeta.clock\n    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {\n      if (state === null) {\n        // never let a remote client remove this local state\n        if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n          // remote client removed the local state. Do not remote state. Broadcast a message indicating\n          // that this client still exists by increasing the clock\n          clock++\n        } else {\n          awareness.states.delete(clientID)\n        }\n      } else {\n        awareness.states.set(clientID, state)\n      }\n      awareness.meta.set(clientID, {\n        clock,\n        lastUpdated: timestamp\n      })\n      if (clientMeta === undefined && state !== null) {\n        added.push(clientID)\n      } else if (clientMeta !== undefined && state === null) {\n        removed.push(clientID)\n      } else if (state !== null) {\n        if (!f.equalityDeep(state, prevState)) {\n          filteredUpdated.push(clientID)\n        }\n        updated.push(clientID)\n      }\n    }\n  }\n  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n    awareness.emit('change', [{\n      added, updated: filteredUpdated, removed\n    }, origin])\n  }\n  if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n    awareness.emit('update', [{\n      added, updated, removed\n    }, origin])\n  }\n}\n"],"names":["BIT7","BIT8","BITS6","BITS7","BITS31","createUint8ArrayViewFromArrayBuffer","buffer","byteOffset","length","Uint8Array","createUint8ArrayFromArrayBuffer","toBase64","bytes","s","i","byteLength","btoa","Buffer","from","toString","fromBase64","a","atob","len","charCodeAt","buf","Decoder","constructor","uint8Array","this","arr","pos","createDecoder","readVarUint8Array","decoder","view","readUint8Array","readVarUint","readUint8","num","r","Error","readVarString","remainingLen","encodedString","String","fromCodePoint","nextLen","subarray","apply","decodeURIComponent","escape","readFromDataView","dv","DataView","readAnyLookupTable","sign","getFloat32","getFloat64","getBigInt64","obj","readAny","push","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","isInteger","isFinite","math","isNaN","parseInt","Encoder","cpos","cbuf","bufs","createEncoder","toUint8Array","encoder","uint8arr","curPos","d","set","write","bufferLen","writeUint8","writeVarUint","writeVarString","str","unescape","encodeURIComponent","codePointAt","writeVarUint8Array","leftCopyLen","rightCopyLen","writeUint8Array","writeOnDataView","verifyLen","dview","floatTestBed","ArrayBuffer","writeAny","data","isNegative","writeVarInt","setFloat32","writeFloat32","setFloat64","writeFloat64","setBigInt64","writeBigInt64","Array","keys","Object","key","isNode","process","release","test","name","isBrowser","window","params","navigator","platform","args","getVariable","undefined","v","env","toUpperCase","storage","map","pargs","argv","currParamName","parg","location","search","slice","split","forEach","kv","value","string","computeParams","has","hasParam","assign","hasProperty","prototype","hasOwnProperty","call","nop","equalityDeep","b","equalityStrict","Set","size","Map","get","create","setIfUndefined","createT","m","f","res","floor","Math","abs","ceil","log10","imul","round","min","log2","log","sqrt","max","isNegativeZero","pow","n","isArray","Observable","_observers","on","add","once","_f","off","observers","delete","emit","values","destroy","_localStorage","setItem","newValue","getItem","usePolyfill","localStorage","e","varStorage","onChange","eventHandler","addEventListener","fromCharCode","trimLeftRegex","fromCamelCaseRegex","fromCamelCase","separator","replace","trimLeft","match","toLowerCase","utf8TextEncoder","TextEncoder","encodeUtf8","encode","utf8TextDecoder","TextDecoder","fatal","ignoreBOM","decode","getUnixTime","Date","now","cachedSetTimeout","cachedClearTimeout","module","exports","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","run","marker","runClearTimeout","Item","array","noop","nextTick","arguments","title","browser","version","versions","addListener","removeListener","removeAllListeners","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","Awareness","doc","super","clientID","states","meta","_checkInterval","setInterval","getLocalState","outdatedTimeout","lastUpdated","setLocalState","remove","clientid","removeAwarenessStates","clearInterval","state","currLocalMeta","clock","prevState","added","updated","filteredUpdated","removed","setLocalStateField","field","getStates","awareness","clients","origin","curMeta","encodeAwarenessUpdate","JSON","stringify","applyAwarenessUpdate","update","timestamp","parse","clientMeta","currClock"],"sourceRoot":""}